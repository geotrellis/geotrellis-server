# MAML: Map Algebra Modeling Language

MAML is an attempt to produce an abstract syntax tree (AST) sufficient
to describe common operations on raster data. It includes serialization
for this AST (via the wonderful `Circe` library) and a reference
implementation for interpreting these ASTs as programs which yield imagery.

#### Writing MAML for OGC layers

In many cases, MAML will be generated by other programs and used to
execute map algebra programs in other contexts. A javascript client can,
for instance, define complex math on rasters which would be impossible
or incredibly unreliable to execute client-side. We use it in a slightly
different fashion here, in the configuration of layers: instead of being
generated mechanically, MAML json is manually constructed to define
complex (potentially multiple backing sources) layers.

Whereas avro layers (simple layers) refer to a 'source' field, MAML layers
refer to an algebra. That algebra will, e.g., add the values from multiple
layers together. The layers to be added are, themselves, derived from the
list of defined layers. In the example conf, the raster variable (note the
symbol field's `rasterV` entry) corresponding to our Avro-backed
"us-census-median-household-income" is denoted with the JSON:

```json
{
  "name" : "us-census-median-household-income",
  "symbol" : "rasterV"
}
```

Once a reference like this has been established, we can use it to
construct more elaborate programs. Again, assuming we want to add values
together (in this case, simply doubling each cell's value in
us-census-median-household-income), we would write the following in our
layer's "algebra" field:

```json
{
  "args" : [
    {
      "name" : "us-census-median-household-income",
      "symbol" : "rasterV"
    },
    {
      "name" : "us-census-median-household-income",
      "symbol" : "rasterV"
    }
  ],
  "symbol" : "+"
}
```

Note the symbol "+". This is the clue used during deserialization to
construct the correct case class nesting. A full list of the available
symbols (which are sometimes short strings of letters) can be found
[here](maml-operations.md).

#### Interpreting MAML

In addition to the provided AST for describing raster computations, an
implementation of an `Interpreter` is also provided with MAML. It
converts an AST into a program and executes said program. The
`Interpreter` provided by MAML is built up from a set of one or more
instructions which we call `Directive`s. The `Directive` is a
unit of evaluation. Each of these directives is ultimately
just a `PartialFunction`; it is the job of an `Interpreter` to build a
total function from the various partial functions it is supplied. Here's
[the default interpreter](https://github.com/geotrellis/maml/blob/ffcf3fa0db6a58b44aebfa30e0a099bfed590e43/jvm/src/main/scala/eval/NaiveInterpreter.scala#L37-L94).

Note the list of `Directives` it is being supplied at construction and compare
them to this [list of available MAML operations](maml-operations.md).
Each operation has *at least* one directive (sometimes more as a result
of support for polymorphic return values in MAML).

IF a new `Expression` is added to MAML and no corresponding `Directive`
is supplied to the `Interpreter`, the `Interpreter` will evaluate results
up from the leaves until it reaches the new node. Upon reaching the new
node, the "fallback directive" (a catch-all provided by `Interpreter`s)
will be executed and the program will report an `UnhandledCase` error.


#### Changing Behavior of the Provided Interpreter

Because the structure of the `Interpreter`s we've provided is designed
to to be highly modular, individual directives can be replaced
if desired. There are two necessary steps
1. construction of the new `Directive`
2. registration of the new `Directive` when constructing an `Interpreter`


##### Constructing a Directive

As mentioned, a `Directive` is really just a `PartialFunction`. This
partial function takes an `Expression` and its (evaluated) children and
returns an evaluated result (which is of type `Result` and can contain
Imagery as well as numeric or geometric results). Here's an example of
defining the behavior of our interpreter whenever it runs into an
`Addition` node that's supposed to produce imagery:

```scala
val myAddition = Directive { case (a@Addition(_), childResults) if (a.kind == MamlKind.Image) =>
  // Children results grouped according to their reported MamlKind
  val grouped = childResults.groupBy(_.kind)

  // Helpers that unwrap the contents of Result instances
  def doubleResults(grouped: Map[MamlKind, Seq[Result]]): Interpreted[List[Double]] =
    grouped.getOrElse(MamlKind.Double, List.empty).map(_.as[Double]).toList.sequence
  def intResults(grouped: Map[MamlKind, Seq[Result]]): Interpreted[List[Int]] =
    grouped.getOrElse(MamlKind.Int, List.empty).map(_.as[Int]).toList.sequence
  def imageResults(grouped: Map[MamlKind, Seq[Result]]): Interpreted[List[LazyMultibandRaster]] =
    grouped(MamlKind.Image).map(_.as[LazyMultibandRaster]).toList.sequence

  // Carry out addition on scalars first for optimal performance (commutativity ftw)
  val scalarSums =
    (doubleResults(grouped), intResults(grouped)).mapN { case (dbls, ints) => dbls.sum + ints.sum }

  // Finally, reduce over the children images, adding them together and finally supplementing each
  //  resultant cell's value with the scalarSums from above
  (imageResults(grouped), scalarSums).mapN { case (tiles, sums) =>
    val tileSum = tiles.reduce({ (lt1: LazyMultibandRaster, lt2: LazyMultibandRaster) => lt1.dualCombine(lt2, {_ + _}, {_ + _}) })
    ImageResult(tileSum.dualMap({ i: Int => i + sums.toInt }, { i: Double => i + sums }))
  }
}
```

Because the construct underlying `Directive` is simply that of the
partial function, we are free to do whatever we like in the body of the
function.


###### Constructing a new Interpreter

`Interpreter`s are little more than a set of `Directive`s, an ordering
for their attempted application (earlier listed directives are attempted
sooner), and a fallback directive (provided by the `Interpreter` and used
whenever an unrecognized node is encountered). Here's an example capable
of handling `Addition` (using the above `Directive`) and nothing else:

```scala
NaiveInterpreter(List(myAddition))
```

A more complete example can be found
[here](https://github.com/geotrellis/maml/blob/ffcf3fa0db6a58b44aebfa30e0a099bfed590e43/jvm/src/main/scala/eval/NaiveInterpreter.scala#L37-L94).

